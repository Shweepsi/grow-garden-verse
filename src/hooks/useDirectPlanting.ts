import { useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from '@/hooks/useAuth';
import { useGameData } from '@/hooks/useGameData';
import { useGameMultipliers } from '@/hooks/useGameMultipliers';
import { EconomyService } from '@/services/EconomyService';
import { toast } from 'sonner';
import { MAX_PLOTS } from '@/constants';

export const useDirectPlanting = () => {
  const { user } = useAuth();
  const queryClient = useQueryClient();
  const { data: gameData } = useGameData();

  const plantDirectMutation = useMutation({
    mutationFn: async ({ plotNumber, plantTypeId, expectedCost }: {
      plotNumber: number;
      plantTypeId: string;
      expectedCost: number;
    }) => {
      if (!user?.id) throw new Error('Not authenticated');

      // Validation stricte du num√©ro de parcelle
      if (!plotNumber || plotNumber < 1 || plotNumber > MAX_PLOTS) {
        throw new Error('Num√©ro de parcelle invalide');
      }

      console.log(`üå± D√©but de la plantation directe sur la parcelle ${plotNumber}`);

      // R√©cup√©rer les infos de la parcelle
      const { data: plot, error: plotError } = await supabase
        .from('garden_plots')
        .select('*')
        .eq('user_id', user.id)
        .eq('plot_number', plotNumber)
        .single();

      if (plotError) {
        console.error('‚ùå Erreur parcelle:', plotError);
        throw new Error(`Erreur lors de la r√©cup√©ration de la parcelle: ${plotError.message}`);
      }

      if (!plot) {
        throw new Error('Parcelle non trouv√©e');
      }

      if (!plot.unlocked) {
        throw new Error('Cette parcelle n\'est pas encore d√©bloqu√©e');
      }

      if (plot.plant_type) {
        throw new Error('Cette parcelle contient d√©j√† une plante');
      }

      // R√©cup√©rer le type de plante
      const { data: plantType, error: plantTypeError } = await supabase
        .from('plant_types')
        .select('*')
        .eq('id', plantTypeId)
        .single();

      if (plantTypeError || !plantType) {
        throw new Error('Type de plante non trouv√©');
      }

      console.log('üå± Type de plante:', plantType.display_name);

      // Obtenir les donn√©es du jardin
      const { data: garden, error: gardenError } = await supabase
        .from('player_gardens')
        .select('*')
        .eq('user_id', user.id)
        .single();

      if (gardenError || !garden) {
        throw new Error('Jardin non trouv√©');
      }

      // V√©rifier le niveau requis
      const playerLevel = garden.level || 1;
      const requiredLevel = plantType.level_required || 1;
      
      if (playerLevel < requiredLevel) {
        throw new Error(`Niveau ${requiredLevel} requis pour cette plante`);
      }

      // Obtenir les multiplicateurs complets (permanent + boosts)
      let multipliers;
      try {
        const { getCompleteMultipliers } = useGameMultipliers();
        multipliers = getCompleteMultipliers();
        console.log('üí™ Multiplicateurs complets (permanent + boosts):', multipliers);
      } catch (error) {
        console.warn('‚ö†Ô∏è Erreur lors de la r√©cup√©ration des multiplicateurs, utilisation des valeurs par d√©faut:', error);
        multipliers = { harvest: 1, growth: 1 };
      }

      // Calculer le co√ªt avec multiplicateurs
      const baseCost = EconomyService.getPlantDirectCost(requiredLevel);
      const actualCost = EconomyService.getAdjustedPlantCost(baseCost, multipliers.plantCostReduction || 1);

      // V√©rification du co√ªt attendu (s√©curit√© anti-cheat basique)
      if (Math.abs(actualCost - expectedCost) > 1) {
        console.warn(`‚ö†Ô∏è √âcart de co√ªt d√©tect√©: attendu ${expectedCost}, calcul√© ${actualCost}`);
        throw new Error('Erreur de co√ªt, veuillez recharger la page');
      }

      // V√©rifier les fonds
      if (!EconomyService.canAffordPlant(garden.coins, actualCost)) {
        throw new Error('Pas assez de pi√®ces pour planter');
      }

      console.log(`üí∞ Co√ªt de plantation: ${actualCost} pi√®ces`);

      // Calculer le temps de croissance ajust√©
      const baseGrowthSeconds = plantType.base_growth_seconds || 60;
      const adjustedGrowthTime = EconomyService.getAdjustedGrowthTime(baseGrowthSeconds, multipliers.growth || 1);

      console.log(`‚è∞ Temps de croissance: ${adjustedGrowthTime}s (base: ${baseGrowthSeconds}s)`);

      const now = new Date().toISOString();

      // Planter sur la parcelle
      const { error: updatePlotError } = await supabase
        .from('garden_plots')
        .update({
          plant_type: plantTypeId,
          planted_at: now,
          growth_time_seconds: adjustedGrowthTime,
          updated_at: now
        })
        .eq('user_id', user.id)
        .eq('plot_number', plotNumber);

      if (updatePlotError) {
        console.error('‚ùå Erreur plantation:', updatePlotError);
        throw new Error(`Erreur lors de la plantation: ${updatePlotError.message}`);
      }

      console.log('üå± Plantation r√©ussie sur la parcelle');

      // D√©duire le co√ªt du jardin
      const { error: updateGardenError } = await supabase
        .from('player_gardens')
        .update({
          coins: garden.coins - actualCost,
          last_played: now
        })
        .eq('user_id', user.id);

      if (updateGardenError) {
        console.error('‚ùå Erreur mise √† jour jardin:', updateGardenError);
        throw new Error(`Erreur lors de la mise √† jour du jardin: ${updateGardenError.message}`);
      }

      console.log('üè° Jardin mis √† jour');

      // Enregistrer la transaction
      try {
        await supabase
          .from('coin_transactions')
          .insert({
            user_id: user.id,
            amount: -actualCost,
            transaction_type: 'plant',
            description: `Plantation de ${plantType.display_name}`
          });
        console.log('üí≥ Transaction enregistr√©e');
      } catch (error) {
        console.warn('‚ö†Ô∏è Erreur lors de l\'enregistrement de la transaction:', error);
      }

      console.log('‚úÖ Plantation directe termin√©e avec succ√®s');
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['gameData'] });
    },
    onError: (error: any) => {
      console.error('üí• Erreur lors de la plantation directe:', error);
      toast.error(error.message || 'Erreur lors de la plantation');
    }
  });

  const { getCompleteMultipliers } = useGameMultipliers();

  return {
    plantDirect: (plotNumber: number, plantTypeId: string, expectedCost: number) => 
      plantDirectMutation.mutate({ plotNumber, plantTypeId, expectedCost }),
    isPlanting: plantDirectMutation.isPending,
    isPlantingPlot: (plotNumber: number) => plantDirectMutation.isPending,
    getActiveMultipliers: getCompleteMultipliers
  };
};